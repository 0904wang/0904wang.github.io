<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>NULL</title>
    <link>http://wangzhilei.fun/</link>
    
    <atom:link href="http://wangzhilei.fun/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>看到我请叫我去学习</description>
    <pubDate>Sun, 14 Jul 2024 15:37:35 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Python数据结构--丰富的序列</title>
      <link>http://wangzhilei.fun/2024/07/14/Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%B0%E5%AF%8C%E7%9A%84%E5%BA%8F%E5%88%97/</link>
      <guid>http://wangzhilei.fun/2024/07/14/Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%B0%E5%AF%8C%E7%9A%84%E5%BA%8F%E5%88%97/</guid>
      <pubDate>Sun, 14 Jul 2024 15:37:09 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;本节主要内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;列表推导式和生成器表达式&lt;/li&gt;
&lt;li&gt;元组的两种用法——记录和不可变列表&lt;/li&gt;
&lt;li&gt;序列拆包和序列模式&lt;/li&gt;
&lt;li&gt;读写切片&lt;/li&gt;
&lt;li&gt;专门的序列类型，例如数组和队列&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=</description>
        
      
      
      
      <content:encoded><![CDATA[<p>本节主要内容：</p><ul><li>列表推导式和生成器表达式</li><li>元组的两种用法——记录和不可变列表</li><li>序列拆包和序列模式</li><li>读写切片</li><li>专门的序列类型，例如数组和队列</li></ul><h1 id="1-1-内置序列类型概览">1.1 内置序列类型概览</h1><p>可简单分为：</p><ul><li>容器序列：可存放不同类型的项，其中包括嵌套容器。例如：list、tuple和collections.deque。</li><li>扁平序列：可存放一种简单类型的项。例如：str、bytes和array.array。<br>另外，还可按可变性对序列分类。</li><li>可变序列：例如list、bytearray、array.array和collections.deque。</li><li>不可变序列：例如tuple、str和bytes。</li></ul><h1 id="1-2列表推导式和生成器推导式">1.2列表推导式和生成器推导式</h1><h2 id="1-2-1可读性">1.2.1可读性</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://wangzhilei.fun/categories/Python/">Python</category>
      
      
      <category domain="http://wangzhilei.fun/tags/%E6%B5%81%E7%95%85%E7%9A%84Python/">流畅的Python</category>
      
      
      <comments>http://wangzhilei.fun/2024/07/14/Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%B0%E5%AF%8C%E7%9A%84%E5%BA%8F%E5%88%97/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Python数据结构--数据结构模型</title>
      <link>http://wangzhilei.fun/2024/07/06/Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E5%9E%8B/</link>
      <guid>http://wangzhilei.fun/2024/07/06/Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E5%9E%8B/</guid>
      <pubDate>Sat, 06 Jul 2024 14:14:02 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;python风格的纸牌&quot;&gt;python风格的纸牌&lt;/h1&gt;
&lt;p&gt;示例&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/sp</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="python风格的纸牌">python风格的纸牌</h1><p>示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line">Card = collections.namedtuple(<span class="string">&#x27;Card&#x27;</span>, [<span class="string">&#x27;rank&#x27;</span>, <span class="string">&#x27;suit&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FrenchDeck</span>:</span><br><span class="line">    ranks = [<span class="built_in">str</span>(n) <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">11</span>)] + <span class="built_in">list</span>(<span class="string">&#x27;JQKA&#x27;</span>)</span><br><span class="line">    suits = <span class="string">&#x27;spades diamonds clubs hearts&#x27;</span>.split()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._cards = [Card(rank, suit) <span class="keyword">for</span> suit <span class="keyword">in</span> self.suits <span class="keyword">for</span> rank <span class="keyword">in</span> self.ranks]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self._cards)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, position</span>):</span><br><span class="line">        <span class="keyword">return</span> self._cards[position]</span><br></pre></td></tr></table></figure><p>这个 FrenchDeck 类是一个模拟法国纸牌牌组的类。它包含了纸牌牌组的基本属性和功能。下面是对这个类的详细解释：<br>类变量：<br>ranks：这是一个列表，包含了一副牌中所有的等级（Rank），即从 2 到 10 的数字和四个面牌（J, Q, K, A）。<br>suits：这是一个列表，包含了一副牌中所有的花色（Suit），即 spades（黑桃）、diamonds（方块）、clubs（梅花）和 hearts（红心）。<br><strong>初始化方法 <strong>init</strong></strong>：<br>在这个方法中，创建了一个名为 _cards 的私有属性，它是一个列表，包含了所有可能的牌面组合。这是通过一个列表推导式完成的，对于 suits 列表中的每一个花色和 ranks 列表中的每一个等级，创建一个 Card 对象。<br><strong>魔术方法 <strong>len</strong></strong>：<br>这个方法使得 FrenchDeck 实例可以使用内置的 len() 函数来获取牌组中牌的数量。它返回 _cards 列表的长度，即牌组中牌的总数。<br><strong>魔术方法 <strong>getitem</strong></strong>：<br>这个方法允许通过索引访问 FrenchDeck 实例中的元素，就像访问列表一样。这意味着你可以使用下标操作（例如 deck[0]）来获取牌组中的特定牌。这也使得 FrenchDeck 实例支持迭代和切片操作，因为这些操作都依赖于 <strong>getitem</strong> 方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">beer_card = Card(<span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;diamonds&#x27;</span>)</span><br><span class="line">beer_card</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">output:Card(rank=&#x27;7&#x27;, suit=&#x27;diamonds&#x27;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deck = FrenchDeck()</span><br><span class="line"><span class="built_in">len</span>(deck)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">output:52</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deck[<span class="number">0</span>]</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">output:Card(rank=&#x27;2&#x27;, suit=&#x27;spades&#x27;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>使用random.choice随机选取一张牌。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line"></span><br><span class="line">choice(deck)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">output:Card(rank=&#x27;5&#x27;, suit=&#x27;clubs&#x27;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>可以看出，通过特殊方法利用python数据模型，有如下两个优点</p><ol><li>类的用户不需要记住标准操作的方法名称（“怎样获取项数？使用.size(),.length()还是其他方法”）</li><li>可以充分利用python标准库，无需重新发明轮子<br>抽取最上面三张及从索引12开始，跳过13张牌，只抽取4张A。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">deck[:<span class="number">3</span>]</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">output:[Card(rank=&#x27;2&#x27;, suit=&#x27;spades&#x27;),</span></span><br><span class="line"><span class="string">Card(rank=&#x27;3&#x27;, suit=&#x27;spades&#x27;), </span></span><br><span class="line"><span class="string">Card(rank=&#x27;4&#x27;, suit=&#x27;spades&#x27;)]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">deck[<span class="number">12</span>::<span class="number">13</span>]</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">output:[Card(rank=&#x27;A&#x27;, suit=&#x27;spades&#x27;), </span></span><br><span class="line"><span class="string">Card(rank=&#x27;A&#x27;, suit=&#x27;diamonds&#x27;), </span></span><br><span class="line"><span class="string">Card(rank=&#x27;A&#x27;, suit=&#x27;clubs&#x27;), </span></span><br><span class="line"><span class="string">Card(rank=&#x27;A&#x27;, suit=&#x27;hearts&#x27;)]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>纸牌还可以迭代：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> card <span class="keyword">in</span> deck:</span><br><span class="line">    <span class="built_in">print</span>(card)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">output:Card(rank=&#x27;2&#x27;, suit=&#x27;spades&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;3&#x27;, suit=&#x27;spades&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;4&#x27;, suit=&#x27;spades&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;5&#x27;, suit=&#x27;spades&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;6&#x27;, suit=&#x27;spades&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;7&#x27;, suit=&#x27;spades&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;8&#x27;, suit=&#x27;spades&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;9&#x27;, suit=&#x27;spades&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;10&#x27;, suit=&#x27;spades&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;J&#x27;, suit=&#x27;spades&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;Q&#x27;, suit=&#x27;spades&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;K&#x27;, suit=&#x27;spades&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;A&#x27;, suit=&#x27;spades&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;2&#x27;, suit=&#x27;diamonds&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;3&#x27;, suit=&#x27;diamonds&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;4&#x27;, suit=&#x27;diamonds&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;5&#x27;, suit=&#x27;diamonds&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;6&#x27;, suit=&#x27;diamonds&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;7&#x27;, suit=&#x27;diamonds&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;8&#x27;, suit=&#x27;diamonds&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;9&#x27;, suit=&#x27;diamonds&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;10&#x27;, suit=&#x27;diamonds&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;J&#x27;, suit=&#x27;diamonds&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;Q&#x27;, suit=&#x27;diamonds&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;K&#x27;, suit=&#x27;diamonds&#x27;)</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">Card(rank=&#x27;J&#x27;, suit=&#x27;hearts&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;Q&#x27;, suit=&#x27;hearts&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;K&#x27;, suit=&#x27;hearts&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;A&#x27;, suit=&#x27;hearts&#x27;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>再进行排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">suit_values = <span class="built_in">dict</span>(spades=<span class="number">3</span>, hearts=<span class="number">2</span>, diamonds=<span class="number">1</span>, clubs=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spades_high</span>(<span class="params">card</span>):</span><br><span class="line">    rank_value = FrenchDeck.ranks.index(card.rank)</span><br><span class="line">    <span class="keyword">return</span> rank_value * <span class="built_in">len</span>(suit_values) + suit_values[card.suit]</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> card <span class="keyword">in</span> <span class="built_in">sorted</span>(deck, key=spades_high):</span><br><span class="line">    <span class="built_in">print</span>(card)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">output:Card(rank=&#x27;2&#x27;, suit=&#x27;clubs&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;2&#x27;, suit=&#x27;diamonds&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;2&#x27;, suit=&#x27;hearts&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;2&#x27;, suit=&#x27;spades&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;3&#x27;, suit=&#x27;clubs&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;3&#x27;, suit=&#x27;diamonds&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;3&#x27;, suit=&#x27;hearts&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;3&#x27;, suit=&#x27;spades&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;4&#x27;, suit=&#x27;clubs&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;4&#x27;, suit=&#x27;diamonds&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;4&#x27;, suit=&#x27;hearts&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;4&#x27;, suit=&#x27;spades&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;5&#x27;, suit=&#x27;clubs&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;5&#x27;, suit=&#x27;diamonds&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;5&#x27;, suit=&#x27;hearts&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;5&#x27;, suit=&#x27;spades&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;6&#x27;, suit=&#x27;clubs&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;6&#x27;, suit=&#x27;diamonds&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;6&#x27;, suit=&#x27;hearts&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;6&#x27;, suit=&#x27;spades&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;7&#x27;, suit=&#x27;clubs&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;7&#x27;, suit=&#x27;diamonds&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;7&#x27;, suit=&#x27;hearts&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;7&#x27;, suit=&#x27;spades&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;8&#x27;, suit=&#x27;clubs&#x27;)</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">Card(rank=&#x27;A&#x27;, suit=&#x27;clubs&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;A&#x27;, suit=&#x27;diamonds&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;A&#x27;, suit=&#x27;hearts&#x27;) </span></span><br><span class="line"><span class="string">Card(rank=&#x27;A&#x27;, suit=&#x27;spades&#x27;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="特殊方法是如何使用的">特殊方法是如何使用的</h1><p>首先明确一点，特殊方法是供python解释器使用的，而不是你自己。也就是说，没有my_object.__len__()这种写法，正确的写法是len(my_object)。</p><h2 id="1-3-1-模拟数值类型">1.3.1 模拟数值类型</h2><p>例二：实现一个二维向量类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x=<span class="number">0</span>, y=<span class="number">0</span></span>):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Vector(%r, %r)&#x27;</span> % (self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__abs__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> math.hypot(self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__bool__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bool</span>(<span class="built_in">abs</span>(self))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        x = self.x + other.x</span><br><span class="line">        y = self.y + other.y</span><br><span class="line">        <span class="keyword">return</span> Vector(x, y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__mul__</span>(<span class="params">self, scalar</span>):</span><br><span class="line">        <span class="keyword">return</span> Vector(self.x * scalar, self.y * scalar)</span><br></pre></td></tr></table></figure><p>向量加法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v1 = Vector(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">v2 = Vector(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">v1 + v2</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">output:Vector(4, 5)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>计算向量的模</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v = Vector(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">abs</span>(v)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">output:5.0</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span> </span><br></pre></td></tr></table></figure><p>实现&quot;*&quot;运算符，计算向量的标量积。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v = v * <span class="number">3</span></span><br><span class="line">v</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">output:Vector(9, 12)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span> </span><br></pre></td></tr></table></figure><h2 id="1-3-2-字符串表示形式">1.3.2 字符串表示形式</h2><p>特殊方法__repr__供内置函数repr调用，获取对象的字符串表示形式。</p><p>与此形成对照的是，__str__方法由内置函数str()调用，在背后供print函数使用。</p><h2 id="1-3-3-自定义类型的布尔值">1.3.3 自定义类型的布尔值</h2><p>默认情况下，用户定义的实例都是真值，除非实现了__bool___或__len__方法。简单来说，bool(x)调用了x.__bool__方法，以后者得到的结果为准。如果没有实现__bool__方法，则python尝试调用x.__len__方法。</p><p>在本例中，如果向量的模为零，则返回False，否则返回True。</p><h2 id="1-3-4-容器api">1.3.4 容器API</h2><p><img src="https://s3.bmp.ovh/imgs/2024/07/12/4c510592e4748a0d.png" alt="基本容器类型"><br>顶部三个抽象基类均只有一个特殊方法。抽象基类Collection统一了这三个基本接口，每一个容器类型均应实现如下事项：</p><ul><li>Iterable要支持for、拆包和其他迭代方式；</li><li>Sized要支持内置函数len；</li><li>Container要支持in运算符。<br>Collection还有三个重要的专用接口：</li><li>Sequence规范list和str等内置类型的接口；</li><li>Mapping被dict、collections.defaultdict等实现；</li><li>Set是set和frozenset两个内置类型的接口。<br>只有Sequence实现了Reversible，因为序列要支持以任意顺序排列内容。</li></ul>]]></content:encoded>
      
      
      <category domain="http://wangzhilei.fun/categories/Python/">Python</category>
      
      
      <category domain="http://wangzhilei.fun/tags/%E6%B5%81%E7%95%85%E7%9A%84Python/">流畅的Python</category>
      
      
      <comments>http://wangzhilei.fun/2024/07/06/Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E5%9E%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>每日一题1-4-读《Python-Codebook》</title>
      <link>http://wangzhilei.fun/2024/07/02/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981-4-%E8%AF%BB%E3%80%8APython-Codebook%E3%80%8B/</link>
      <guid>http://wangzhilei.fun/2024/07/02/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981-4-%E8%AF%BB%E3%80%8APython-Codebook%E3%80%8B/</guid>
      <pubDate>Tue, 02 Jul 2024 13:52:09 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;1-16-筛选序列中的元素&quot;&gt;1.16 筛选序列中的元素&lt;/h1&gt;
&lt;h2 id=&quot;列表推导式&quot;&gt;列表推导式&lt;/h2&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;spa</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="1-16-筛选序列中的元素">1.16 筛选序列中的元素</h1><h2 id="列表推导式">列表推导式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mylist = [<span class="number">1</span>,<span class="number">4</span>,-<span class="number">5</span>,<span class="number">10</span>,-<span class="number">7</span>,<span class="number">2</span>,<span class="number">3</span>,-<span class="number">1</span>]</span><br><span class="line">[n <span class="keyword">for</span> n <span class="keyword">in</span> mylist <span class="keyword">if</span> n &gt; <span class="number">0</span>]</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出：[1, 4, 10, 2, 3]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>但缺点是如果原始数据非常大，这么做会产生一个庞大的结果。可以考虑使用生成器通过迭代的方法筛选结果。</p><h1 id="生成器">生成器</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pos = (n <span class="keyword">for</span> n <span class="keyword">in</span> mylist <span class="keyword">if</span> n &gt; <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(pos)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> pos:</span><br><span class="line">    <span class="built_in">print</span>(x,end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出：&lt;generator object &lt;genexpr&gt; at 0x0000020FDCAD2B90&gt;</span></span><br><span class="line"><span class="string">1 4 10 2 3</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="1-17-从字典中提取子集">1.17 从字典中提取子集</h1><p>使用字典推导式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">prices = &#123;</span><br><span class="line">    <span class="string">&#x27;ACME&#x27;</span>: <span class="number">45.23</span>,</span><br><span class="line">    <span class="string">&#x27;AAPL&#x27;</span>: <span class="number">612.78</span>,</span><br><span class="line">    <span class="string">&#x27;IBM&#x27;</span>: <span class="number">205.55</span>,</span><br><span class="line">    <span class="string">&#x27;HPQ&#x27;</span>: <span class="number">37.20</span>,</span><br><span class="line">    <span class="string">&#x27;FB&#x27;</span>: <span class="number">10.75</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">p1 = &#123;key:value <span class="keyword">for</span> key,value <span class="keyword">in</span> prices.items() <span class="keyword">if</span> value &gt; <span class="number">200</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(p1)</span><br><span class="line">tech_names = &#123;<span class="string">&#x27;AAPL&#x27;</span>, <span class="string">&#x27;IBM&#x27;</span>, <span class="string">&#x27;HPQ&#x27;</span>, <span class="string">&#x27;MSFT&#x27;</span>&#125;</span><br><span class="line">p2 = &#123;key:value <span class="keyword">for</span> key,value <span class="keyword">in</span> prices.items() <span class="keyword">if</span> key <span class="keyword">in</span> tech_names&#125;</span><br><span class="line"><span class="built_in">print</span>(p2)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出：&#123;&#x27;AAPL&#x27;: 612.78, &#x27;IBM&#x27;: 205.55&#125; </span></span><br><span class="line"><span class="string">&#123;&#x27;AAPL&#x27;: 612.78, &#x27;IBM&#x27;: 205.55, &#x27;HPQ&#x27;: 37.2&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="1-18-将名称映射到序列的元素中">1.18 将名称映射到序列的元素中</h1><h2 id="问题">问题</h2><p>通过名称而非位置来访问数据，以减少结构中对位置的依赖性。</p><h2 id="解决方案">解决方案</h2><p>collections.namedtuple()（命名元组）是一种工厂方法，它返回Python中标准元组类型的子类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line">Stock = namedtuple(<span class="string">&#x27;Stock&#x27;</span>, [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;shares&#x27;</span>, <span class="string">&#x27;price&#x27;</span>])</span><br><span class="line">stock = Stock(<span class="string">&#x27;ACME&#x27;</span>, <span class="number">100</span>, <span class="number">123.45</span>)</span><br><span class="line"><span class="built_in">print</span>(stock)</span><br><span class="line"><span class="built_in">print</span>(stock.name)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出：Stock(name=&#x27;ACME&#x27;, shares=100, price=123.45) </span></span><br><span class="line"><span class="string">ACME</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="1-19-同时对数据做转换和换算">1.19 同时对数据做转换和换算</h1><p>在函数参数中使用生成器表达式。<br>比如求平方和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">s = <span class="built_in">sum</span>(x * x <span class="keyword">for</span> x <span class="keyword">in</span> nums)</span><br><span class="line">s</span><br></pre></td></tr></table></figure><h1 id="1-20-将多个映射合并为单个映射">1.20 将多个映射合并为单个映射</h1><p>假设有多个字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;x&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;z&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line">b = &#123;<span class="string">&#x27;y&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;z&#x27;</span>: <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure><p>现在假设执行查找操作，我们想检查这两个字典（例如，先在a中查找，如果没找到再去b中查找）。可以使用collections模块中的ChainMap类解决这个问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> ChainMap</span><br><span class="line">c = ChainMap(a,b)</span><br><span class="line"><span class="built_in">print</span>(c[<span class="string">&#x27;x&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(c[<span class="string">&#x27;y&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(c[<span class="string">&#x27;z&#x27;</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">output：</span></span><br><span class="line"><span class="string">1(from a)</span></span><br><span class="line"><span class="string">2(from b)</span></span><br><span class="line"><span class="string">3(from a)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://wangzhilei.fun/categories/Python/">Python</category>
      
      
      <category domain="http://wangzhilei.fun/tags/Python-Codebook/">Python Codebook</category>
      
      
      <comments>http://wangzhilei.fun/2024/07/02/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981-4-%E8%AF%BB%E3%80%8APython-Codebook%E3%80%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>每日一题1-3-读《Python-Codebook》</title>
      <link>http://wangzhilei.fun/2024/07/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981-3-%E8%AF%BB%E3%80%8APython-Codebook%E3%80%8B/</link>
      <guid>http://wangzhilei.fun/2024/07/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981-3-%E8%AF%BB%E3%80%8APython-Codebook%E3%80%8B/</guid>
      <pubDate>Sun, 30 Jun 2024 23:43:15 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;1-11-对切片命名&quot;&gt;1.11 对切片命名&lt;/h1&gt;
&lt;p&gt;内置的slice()函数可以创建一个切片对象。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="1-11-对切片命名">1.11 对切片命名</h1><p>内置的slice()函数可以创建一个切片对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">items = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(items[<span class="number">1</span>:<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(items[<span class="built_in">slice</span>(<span class="number">1</span>,<span class="number">3</span>)])</span><br></pre></td></tr></table></figure><p>两者的输出相同。</p><h2 id="1-12-找出序列中出现次数最多的元素">1.12 找出序列中出现次数最多的元素</h2><p>collections模块中的Counter类正是为此类问题设计的。</p><blockquote><p><code>Counter</code> 是 Python <code>collections</code> 模块中的一个类，用于计数可哈希对象。它是字典的一个子类，其中元素作为键，它们的计数作为值。<code>Counter</code> 可以用来计算值出现的次数。</p></blockquote><p><code>Counter</code> 类的一些主要特性和用法包括：</p><ul><li><strong>计数元素</strong>：可以从一个可迭代对象或映射对象初始化 <code>Counter</code> 对象，计算各元素出现的次数。</li><li><strong>元素方法</strong>：<code>elements()</code> 方法返回一个迭代器，包含每个元素重复出现次数的所有元素。</li><li><strong>最常见元素</strong>：<code>most_common([n])</code> 方法返回一个列表，包含 n 个最常见元素及其计数，按计数降序排列。</li><li><strong>更新计数</strong>：可以使用 <code>update()</code> 方法从另一个可迭代对象或映射对象添加计数。</li><li><strong>数学运算</strong>：<code>Counter</code> 支持各种数学运算，如加法、减法、交集和并集。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 Counter 对象</span></span><br><span class="line">cnt = Counter([<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印元素计数</span></span><br><span class="line"><span class="built_in">print</span>(cnt)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出最常见的元素</span></span><br><span class="line"><span class="built_in">print</span>(cnt.most_common(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新计数</span></span><br><span class="line">cnt.update([<span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(cnt)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例输出:</span></span><br><span class="line"><span class="comment"># Counter(&#123;&#x27;blue&#x27;: 3, &#x27;red&#x27;: 2, &#x27;green&#x27;: 1&#125;)</span></span><br><span class="line"><span class="comment"># [(&#x27;blue&#x27;, 3), (&#x27;red&#x27;, 2)]</span></span><br><span class="line"><span class="comment"># Counter(&#123;&#x27;blue&#x27;: 4, &#x27;red&#x27;: 3, &#x27;green&#x27;: 2&#125;)</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://wangzhilei.fun/categories/Python/">Python</category>
      
      
      <category domain="http://wangzhilei.fun/tags/Python-Codebook/">Python Codebook</category>
      
      
      <comments>http://wangzhilei.fun/2024/07/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981-3-%E8%AF%BB%E3%80%8APython-Codebook%E3%80%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>每日一题1-2-读《Python-Codebook》</title>
      <link>http://wangzhilei.fun/2024/06/30/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981-2-%E8%AF%BB%E3%80%8APython-Codebook%E3%80%8B/</link>
      <guid>http://wangzhilei.fun/2024/06/30/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981-2-%E8%AF%BB%E3%80%8APython-Codebook%E3%80%8B/</guid>
      <pubDate>Sun, 30 Jun 2024 03:16:45 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;1-6在字典中将键映射到多个值&quot;&gt;1.6在字典中将键映射到多个值&lt;/h1&gt;
&lt;p&gt;将这多个值保存在另一个容器如列表或集合中。&lt;br&gt;
使用collections模块中的defaultdict类。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;collections模块中</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="1-6在字典中将键映射到多个值">1.6在字典中将键映射到多个值</h1><p>将这多个值保存在另一个容器如列表或集合中。<br>使用collections模块中的defaultdict类。</p><blockquote><p>collections模块中的defaultdict类是Python标准库中的一个字典（dict）子类，它提供了所有常规字典的方法。defaultdict的主要特点是在访问不存在的键时，会自动创建该键并将其值设置为一个默认值，这个默认值是通过在创建defaultdict对象时传递给构造器的可调用对象（如函数）返回的。</p></blockquote><p>以下是defaultdict的一些主要特性：</p><ul><li>自动创建不存在的键：当尝试访问一个不存在的键时，defaultdict会自动创建这个键并将其值设置为由默认工厂函数返回的值。</li><li>可指定默认值的类型：可以指定默认值的类型，如list、int、set等，这使得defaultdict非常适合于收集和组织数据。</li><li>简化代码：使用defaultdict可以避免在字典操作中频繁检查键是否存在的代码，使得代码更简洁易读。</li></ul><h1 id="1-7让字典保持有序">1.7让字典保持有序</h1><p>collections模块中的OrderedDict类。当对字典做迭代时，他会严格按照元素初始添加顺序进行。<br>注意：OrderedDict的大小是普通字典的2倍多。</p><h1 id="1-8与字典有关的计算问题">1.8与字典有关的计算问题</h1><p>利用zip()将字典中的键和值反转。</p><h1 id="1-9在两个字典中寻找共同点">1.9在两个字典中寻找共同点</h1><p>通过keys()或items()方法执行常见的集合操作。</p><h1 id="1-10从序列中移除重复项并保持元素间顺序不变">1.10从序列中移除重复项并保持元素间顺序不变</h1><p>通过集合和生成器解决。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dedupe</span>(<span class="params">items</span>):</span><br><span class="line">    seen = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        <span class="keyword">if</span> item <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line">            seen.add(item)</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>]  </span><br><span class="line"><span class="built_in">list</span>(dedupe(a))</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://wangzhilei.fun/categories/Python/">Python</category>
      
      
      <category domain="http://wangzhilei.fun/tags/Python-Codebook/">Python Codebook</category>
      
      
      <comments>http://wangzhilei.fun/2024/06/30/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981-2-%E8%AF%BB%E3%80%8APython-Codebook%E3%80%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>每日一题1.1-读《Python Codebook》</title>
      <link>http://wangzhilei.fun/2024/06/29/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981-1-%E8%AF%BB%E3%80%8APython-Codebook%E3%80%8B/</link>
      <guid>http://wangzhilei.fun/2024/06/29/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981-1-%E8%AF%BB%E3%80%8APython-Codebook%E3%80%8B/</guid>
      <pubDate>Sat, 29 Jun 2024 03:56:20 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;1-1-将序列分解为单独的变量&quot;&gt;1.1 将序列分解为单独的变量&lt;/h1&gt;
&lt;p&gt;简单的赋值操作。&lt;/p&gt;
&lt;h1 id=&quot;1-2从任意长度的可迭代对象中分解元素&quot;&gt;1.2从任意长度的可迭代对象中分解元素&lt;/h1&gt;
&lt;p&gt;“*表达式”得到列表。&lt;/p&gt;
&lt;h1 i</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="1-1-将序列分解为单独的变量">1.1 将序列分解为单独的变量</h1><p>简单的赋值操作。</p><h1 id="1-2从任意长度的可迭代对象中分解元素">1.2从任意长度的可迭代对象中分解元素</h1><p>“*表达式”得到列表。</p><h1 id="1-3保存最后n个元素">1.3保存最后N个元素</h1><h2 id="collection-deque方法">collection.deque方法</h2><blockquote><p><code>collections.deque</code>是Python标准库<code>collections</code>模块中的一个类，提供了一个双端队列。双端队列（deque，全称double-ended queue）是一种具有队列和栈性质的抽象数据类型。它允许你从两端附加和弹出元素，因此提供了一种灵活的数据存储方式。</p></blockquote><p><code>collections.deque</code>的主要特点和用法包括：</p><ol><li><strong>快速添加和弹出</strong>：与列表相比，<code>deque</code>在两端添加（append）和弹出（pop）操作的时间复杂度都是O(1)，而列表在头部添加和弹出的时间复杂度是O(n)。</li><li><strong>线程安全</strong>：<code>deque</code>是线程安全的，可以在多线程环境中使用，而无需额外的锁定机制。</li><li><strong>支持最大长度</strong>：可以限制<code>deque</code>的大小。当限定的大小被超出时，添加新元素会导致对应端的旧元素被移除。</li><li><strong>支持迭代</strong>：<code>deque</code>支持迭代，可以像列表一样进行循环遍历。</li><li><strong>支持索引访问</strong>：虽然<code>deque</code>支持从两端快速添加和弹出元素，但也支持索引访问。不过，索引访问的时间复杂度是O(n)，因此在大量数据的情况下不推荐使用。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个空的双端队列</span></span><br><span class="line">d = deque()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在右侧添加元素</span></span><br><span class="line">d.append(<span class="number">1</span>)</span><br><span class="line">d.append(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在左侧添加元素</span></span><br><span class="line">d.appendleft(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 弹出右侧元素</span></span><br><span class="line">right_elem = d.pop()  <span class="comment"># 返回2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 弹出左侧元素</span></span><br><span class="line">left_elem = d.popleft()  <span class="comment"># 返回0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定最大长度创建deque</span></span><br><span class="line">limited_d = deque(maxlen=<span class="number">2</span>)</span><br><span class="line">limited_d.append(<span class="number">1</span>)</span><br><span class="line">limited_d.append(<span class="number">2</span>)</span><br><span class="line">limited_d.append(<span class="number">3</span>)  <span class="comment"># 添加3的同时，1会从左侧被移除</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># 输出当前deque的内容</span></span><br><span class="line"><span class="built_in">print</span>(limited_d)  <span class="comment"># 输出限定长度的deque内容</span></span><br></pre></td></tr></table></figure><h2 id="yield关键字">yield关键字</h2><blockquote><p>在Python中，<code>yield</code>是一个关键字，用于从一个函数返回一个生成器（generator）。使用<code>yield</code>的函数被称为生成器函数。生成器提供了一种方式来产生数据序列，但与返回列表不同，生成器一次只产生一个值，这样可以减少内存使用，提高效率，特别是在处理大数据集时。</p></blockquote><p>使用<code>yield</code>的函数在执行时，每遇到一个<code>yield</code>语句就会暂停并保存当前所有的运行信息，返回<code>yield</code>的值，并在下一次执行<code>next()</code>方法时从当前位置继续运行。<br>以下是<code>yield</code>的一些主要特点：</p><ol><li><strong>惰性求值</strong>：生成器只有在需要产生下一个数据时才会执行。</li><li><strong>状态保持</strong>：生成器函数在暂停执行时，会保持其状态，包括局部变量和指针信息，等待下一次从上次离开的地方继续执行。</li><li><strong>内存效率</strong>：由于一次只处理一个数据项，生成器不需要像列表那样存储整个数据集，这对于大数据处理非常有用。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">simple_generator</span>():</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个生成器对象</span></span><br><span class="line">gen = simple_generator()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用next()获取生成器的下一个元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))  <span class="comment"># 输出 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))  <span class="comment"># 输出 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(gen))  <span class="comment"># 输出 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次调用next(gen)将会抛出StopIteration异常，因为生成器没有更多的元素</span></span><br></pre></td></tr></table></figure><p>生成器非常适合于遍历大文件、表示无限序列和处理流式数据等场景。使用<code>yield</code>可以使代码更加清晰，更易于理解，同时提高程序的性能。</p><h1 id="1-4-找到最小或最大的元素">1.4 找到最小或最大的元素</h1><p>heapq模块的nlargest()和nsmallest()方法。这两个函数都可以接受一个参数key。</p><h1 id="1-5-实现优先级队列">1.5 实现优先级队列</h1><p>利用heapq模块，引入index生成一个堆，依此弹出即可。</p>]]></content:encoded>
      
      
      <category domain="http://wangzhilei.fun/categories/Python/">Python</category>
      
      
      <category domain="http://wangzhilei.fun/tags/Python-Codebook/">Python Codebook</category>
      
      
      <comments>http://wangzhilei.fun/2024/06/29/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981-1-%E8%AF%BB%E3%80%8APython-Codebook%E3%80%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Python爬虫（三）</title>
      <link>http://wangzhilei.fun/2024/06/28/Python%E7%88%AC%E8%99%AB%EF%BC%88%E4%B8%89%EF%BC%89/</link>
      <guid>http://wangzhilei.fun/2024/06/28/Python%E7%88%AC%E8%99%AB%EF%BC%88%E4%B8%89%EF%BC%89/</guid>
      <pubDate>Fri, 28 Jun 2024 03:43:24 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;主要是实战部分&lt;/p&gt;
&lt;h1 id=&quot;豆瓣排行&quot;&gt;豆瓣排行&lt;/h1&gt;
&lt;p&gt;主要目的是爬取豆瓣top250，并存储在Excel里。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr</description>
        
      
      
      
      <content:encoded><![CDATA[<p>主要是实战部分</p><h1 id="豆瓣排行">豆瓣排行</h1><p>主要目的是爬取豆瓣top250，并存储在Excel里。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line">PageIndex = <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">250</span>, <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">DownloadAllHtmls</span>() -&gt; <span class="built_in">list</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    爬取10个页面的HTML</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Referer&#x27;</span>: <span class="string">&#x27;https://wangzhilei.fun&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    htmls = []</span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> PageIndex:</span><br><span class="line">        url = <span class="string">f&quot;https://movie.douban.com/top250?start=<span class="subst">&#123;idx&#125;</span>&amp;filter=&quot;</span></span><br><span class="line">        <span class="comment"># print(f&quot;craw html: &#123;url&#125;&quot;)</span></span><br><span class="line">        r = requests.get(url,headers=headers,timeout=<span class="number">3</span> )</span><br><span class="line">        <span class="keyword">if</span> r.status_code != <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">        htmls.append(r.text)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> htmls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ParseSingleHtml</span>(<span class="params">html</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    解析单个HTML，得到数据</span></span><br><span class="line"><span class="string">    :return: list(&#x27;link&#x27;,&#x27;title&#x27;,[label])</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    soup = BeautifulSoup(html,<span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line">    ArticleItems = (soup.find(<span class="string">&#x27;div&#x27;</span>, class_ = <span class="string">&#x27;article&#x27;</span>).find(<span class="string">&#x27;ol&#x27;</span>,class_ = <span class="string">&#x27;grid_view&#x27;</span>).find_all(<span class="string">&#x27;div&#x27;</span>,class_ = <span class="string">&#x27;item&#x27;</span>))</span><br><span class="line">    datas = []</span><br><span class="line">    <span class="keyword">for</span> ArticleItem <span class="keyword">in</span> ArticleItems:</span><br><span class="line">        rank = ArticleItem.find(<span class="string">&quot;div&quot;</span>, class_ = <span class="string">&#x27;pic&#x27;</span>).find(<span class="string">&quot;em&quot;</span>,class_ = <span class="string">&quot;&quot;</span>).get_text()</span><br><span class="line">        info = ArticleItem.find(<span class="string">&#x27;div&#x27;</span>, class_ = <span class="string">&#x27;info&#x27;</span>)</span><br><span class="line">        title = info.find(<span class="string">&#x27;div&#x27;</span>,class_ = <span class="string">&#x27;hd&#x27;</span>).find(<span class="string">&#x27;span&#x27;</span>,class_ = <span class="string">&#x27;title&#x27;</span>).get_text()</span><br><span class="line">        stars = (info.find(<span class="string">&#x27;div&#x27;</span>,class_ = <span class="string">&#x27;bd&#x27;</span>).find(<span class="string">&#x27;div&#x27;</span>,class_ = <span class="string">&#x27;star&#x27;</span>).find_all(<span class="string">&#x27;span&#x27;</span>))</span><br><span class="line">        rating_star = stars[<span class="number">0</span>][<span class="string">&quot;class&quot;</span>][<span class="number">0</span>]</span><br><span class="line">        rating_num = stars[<span class="number">1</span>].get_text()</span><br><span class="line">        comments = stars[<span class="number">3</span>].get_text()</span><br><span class="line">        datas.append(&#123;</span><br><span class="line">            <span class="string">&quot;rank&quot;</span>:rank,</span><br><span class="line">            <span class="string">&quot;title&quot;</span>:title,</span><br><span class="line">            <span class="string">&quot;rating_star&quot;</span>:rating_star.replace(<span class="string">&quot;rating&quot;</span>,<span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;-t&quot;</span>,<span class="string">&quot;&quot;</span>),</span><br><span class="line">            <span class="string">&quot;rating_num&quot;</span>:rating_num,</span><br><span class="line">            <span class="string">&quot;comments&quot;</span>:comments.replace(<span class="string">&quot;人评价&quot;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="keyword">return</span> datas</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">htmls = DownloadAllHtmls()</span><br><span class="line"></span><br><span class="line">AllDatas = []</span><br><span class="line"><span class="keyword">for</span> html <span class="keyword">in</span> htmls:</span><br><span class="line">    AllDatas.extend(ParseSingleHtml(html))</span><br><span class="line">df = pd.DataFrame(AllDatas)</span><br><span class="line">df.to_excel(<span class="string">&quot;豆瓣电影top250.xlsx&quot;</span>)</span><br></pre></td></tr></table></figure><p>得到<a href="/resources/豆瓣电影top250.xlsx" download>豆瓣电影top250.xlsx</a></p><h1 id="爬取岳麓区历史天气">爬取岳麓区历史天气</h1><p>涉及技术:</p><ol><li>headers中设置user agent反爬机制</li><li>通过network抓包，分析ajax的请求和参数</li><li>通过for循环请求不同的参数的数据</li><li>利用pandas实现excel的合并与保存</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">craw_table</span>(<span class="params">year, month</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    根据年月确定爬取的数据</span></span><br><span class="line"><span class="string">    :param year:</span></span><br><span class="line"><span class="string">    :param month:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    params = &#123;</span><br><span class="line">        <span class="string">&quot;areaInfo[areaId]&quot;</span>: <span class="number">71952</span>,</span><br><span class="line">        <span class="string">&quot;areaInfo[areaType]&quot;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">&quot;date[year]&quot;</span>: year,</span><br><span class="line">        <span class="string">&quot;date[month]&quot;</span>: month,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    response = requests.get(URL, headers=headers, params=params, timeout=<span class="number">3</span>)</span><br><span class="line">    data = response.json()[<span class="string">&quot;data&quot;</span>]</span><br><span class="line">    <span class="comment"># 使用StringIO包装HTML字符串</span></span><br><span class="line">    df = pd.read_html(StringIO(data))[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> df</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">URL = <span class="string">&quot;https://tianqi.2345.com/Pc/GetHistory&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 后来发现只要有&quot;Cookie&quot;和&quot;Referer&quot;这个键就行</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Cookie&quot;</span>: <span class="string">&quot;positionCityID=71952; positionCityPinyin=yuelu; Hm_lvt_a3f2879f6b3620a363bec646b7a8bcdd=1719578091; lastCountyId=71952; lastCountyPinyin=yuelu; lastProvinceId=23; lastCityId=57687; Hm_lpvt_a3f2879f6b3620a363bec646b7a8bcdd=1719578124; lastCountyTime=1719578124&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Referer&quot;</span>: <span class="string">&quot;https://tianqi.2345.com/wea_history/71952.htm&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">df_list = []</span><br><span class="line"><span class="keyword">for</span> used_year <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2020</span>, <span class="number">2024</span>):</span><br><span class="line">    <span class="keyword">for</span> used_month <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">13</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;used_year&#125;</span> <span class="subst">&#123;used_month&#125;</span>&quot;</span>)</span><br><span class="line">        needed_df = craw_table(used_year, used_month)</span><br><span class="line">        df_list.append(needed_df)</span><br><span class="line">pd.concat(df_list).to_excel(<span class="string">&quot;岳麓区历史天气数据.xlsx&quot;</span>, index=<span class="literal">False</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>得到<a href="/resources/岳麓区历史天气数据.xlsx" download>岳麓区历史天气数据.xlsx</a></p><h1 id="爬取小说">爬取小说</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">爬取小说</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_novel_chapters</span>() -&gt;<span class="built_in">list</span>:</span><br><span class="line">    <span class="keyword">global</span> novel_name</span><br><span class="line">    root_url = <span class="built_in">input</span>()</span><br><span class="line">    r = requests.get(root_url,timeout=<span class="number">3</span>)</span><br><span class="line">    r.encoding = <span class="string">&quot;gbk&quot;</span></span><br><span class="line">    novel_soup = BeautifulSoup(r.text,<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">    chapters = []</span><br><span class="line">    novel_name = novel_soup.find(<span class="string">&quot;div&quot;</span>,<span class="built_in">id</span>=<span class="string">&quot;info&quot;</span>).find(<span class="string">&#x27;h1&#x27;</span>).get_text()</span><br><span class="line">    <span class="keyword">for</span> dd <span class="keyword">in</span> novel_soup.find_all(<span class="string">&quot;dd&quot;</span>):</span><br><span class="line">        chapters_link = dd.find(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> chapters_link:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        chapters.append((<span class="string">f&quot;<span class="subst">&#123;root_url&#125;</span><span class="subst">&#123;chapters_link[<span class="string">&#x27;href&#x27;</span>][<span class="number">10</span>:]&#125;</span>&quot;</span>, chapters_link.text))</span><br><span class="line">    <span class="keyword">return</span> chapters</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_chapter_content</span>(<span class="params">url</span>):</span><br><span class="line">    r = requests.get(url,timeout=<span class="number">3</span>)</span><br><span class="line">    r.encoding = <span class="string">&#x27;gbk&#x27;</span></span><br><span class="line">    chapter_soup = BeautifulSoup(r.text, <span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">    chapter_content = chapter_soup.find(<span class="string">&quot;div&quot;</span>, <span class="built_in">id</span>=<span class="string">&quot;content&quot;</span>).get_text()</span><br><span class="line">    chapter_content = chapter_content.replace(<span class="string">&#x27;\xa0&#x27;</span>, <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> chapter_content</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">novel_chapters = get_novel_chapters()</span><br><span class="line"><span class="keyword">for</span> chapter <span class="keyword">in</span> novel_chapters[<span class="number">9</span>:]:</span><br><span class="line">    chapter_url, chapter_title = chapter</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;novel_name&#125;</span>.txt&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> fout:</span><br><span class="line">        fout.write(chapter_title)</span><br><span class="line">        fout.write(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        fout.write(get_chapter_content(chapter_url))</span><br></pre></td></tr></table></figure><p>批量爬取的时候好像IP地址被拉黑了，网站都打不开。。。<br>但代码应该没啥问题。</p>]]></content:encoded>
      
      
      <category domain="http://wangzhilei.fun/categories/Python/">Python</category>
      
      
      <category domain="http://wangzhilei.fun/tags/Python%E7%88%AC%E8%99%AB/">Python爬虫</category>
      
      
      <comments>http://wangzhilei.fun/2024/06/28/Python%E7%88%AC%E8%99%AB%EF%BC%88%E4%B8%89%EF%BC%89/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Python爬虫（二）</title>
      <link>http://wangzhilei.fun/2024/06/25/Python%E7%88%AC%E8%99%AB%EF%BC%88%E4%BA%8C%EF%BC%89/</link>
      <guid>http://wangzhilei.fun/2024/06/25/Python%E7%88%AC%E8%99%AB%EF%BC%88%E4%BA%8C%EF%BC%89/</guid>
      <pubDate>Mon, 24 Jun 2024 16:16:44 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;再次尝试爬取自己的博客&quot;&gt;再次尝试爬取自己的博客&lt;/h1&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;sp</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="再次尝试爬取自己的博客">再次尝试爬取自己的博客</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> unquote</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://www.wangzhilei.fun&quot;</span></span><br><span class="line"></span><br><span class="line">r=requests.get(url)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> r.status_code != <span class="number">200</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception()</span><br><span class="line">r.encoding =<span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line">html_doc=r.text</span><br><span class="line">soup = BeautifulSoup(html_doc,<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">div_nodes = soup.find_all(<span class="string">&quot;div&quot;</span>,class_ = <span class="string">&quot;recent-post-info&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> div_node <span class="keyword">in</span> div_nodes:</span><br><span class="line">    link = div_node.find(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(unquote(link[<span class="string">&quot;href&quot;</span>]),link.get_text())<span class="comment"># urllib.parse.unquote()函数解码</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;================================&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://s3.bmp.ovh/imgs/2024/06/30/10e0f162574b4a2b.png" alt=""></p><p>爬取成功！！！</p><h1 id="爬取博客网站所有文章列表">爬取博客网站所有文章列表</h1><p>知识点：</p><ul><li>附带cookie字典</li><li>正则表达式实现模糊匹配</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> unquote</span><br><span class="line"><span class="keyword">from</span> utlis <span class="keyword">import</span> url_manager</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">RootURL = <span class="string">&#x27;https://wangzhilei.fun&#x27;</span></span><br><span class="line"></span><br><span class="line">URLS = url_manager.UrlManager()</span><br><span class="line">URLS.add_new_url(RootURL)</span><br><span class="line"></span><br><span class="line">fout = <span class="built_in">open</span>(<span class="string">&quot;craw_all_pages.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> URLS.has_new_url():</span><br><span class="line">    CurrUrl = URLS.get_url()</span><br><span class="line">    r = requests.get(CurrUrl, timeout=<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">if</span> r.status_code != <span class="number">200</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    soup = BeautifulSoup(r.text,<span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line">    title = soup.title.string</span><br><span class="line"></span><br><span class="line">    fout.write(<span class="string">f&#x27;<span class="subst">&#123;urllib.parse.unquote(CurrUrl)&#125;</span> <span class="subst">&#123;title&#125;</span>\n&#x27;</span>)</span><br><span class="line">    fout.flush()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;success:<span class="subst">&#123;CurrUrl&#125;</span> <span class="subst">&#123;title&#125;</span> <span class="subst">&#123;<span class="built_in">len</span>(URLS.new_urls)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    links = soup.find_all(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> link <span class="keyword">in</span> links:</span><br><span class="line">        href = link.get(<span class="string">&#x27;href&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> href <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        pattern = <span class="string">r&quot;/\d&#123;4&#125;/\d&#123;2&#125;/\d&#123;2&#125;/.*$&quot;</span></span><br><span class="line">        <span class="keyword">if</span> re.<span class="keyword">match</span>(pattern, href):</span><br><span class="line">            full_url = urllib.parse.urljoin(RootURL, href)</span><br><span class="line">            <span class="comment"># print(f&#x27;full_url:&#123;unquote(full_url)&#125;&#x27;)</span></span><br><span class="line">            decoded_url = urllib.parse.unquote(full_url)</span><br><span class="line">            URLS.add_new_url(decoded_url)</span><br><span class="line"></span><br><span class="line">fout.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出如下：</p><p><img src="https://s3.bmp.ovh/imgs/2024/06/30/476376a6bface38f.png" alt=""></p><p>得到的文档如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">https://wangzhilei.fun NULL</span><br><span class="line">https://wangzhilei.fun/2024/06/23/Python爬虫（一）/ Python爬虫（一） | NULL</span><br><span class="line">https://wangzhilei.fun/2024/06/22/PAM4与OFDM代码分析/ PAM4与OFDM代码分析 | NULL</span><br><span class="line">https://wangzhilei.fun/2024/05/30/test/ test | NULL</span><br><span class="line">https://wangzhilei.fun/2024/06/25/Python爬虫（二）/ Python爬虫（二） | NULL</span><br><span class="line">https://wangzhilei.fun/2024/06/22/OFDM时频图/ OFDM时频图 | NULL</span><br><span class="line">https://wangzhilei.fun/2024/06/21/latex公式/ latex公式 | NULL</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>爬取成功！！！</p>]]></content:encoded>
      
      
      <category domain="http://wangzhilei.fun/categories/Python/">Python</category>
      
      
      <category domain="http://wangzhilei.fun/tags/Python%E7%88%AC%E8%99%AB/">Python爬虫</category>
      
      
      <comments>http://wangzhilei.fun/2024/06/25/Python%E7%88%AC%E8%99%AB%EF%BC%88%E4%BA%8C%EF%BC%89/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Python爬虫（一）</title>
      <link>http://wangzhilei.fun/2024/06/23/Python%E7%88%AC%E8%99%AB%EF%BC%88%E4%B8%80%EF%BC%89/</link>
      <guid>http://wangzhilei.fun/2024/06/23/Python%E7%88%AC%E8%99%AB%EF%BC%88%E4%B8%80%EF%BC%89/</guid>
      <pubDate>Sun, 23 Jun 2024 04:55:07 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;笔者在大一时曾系统学习过python，但也只掌握了一些基础的语法知识，并没有真正的深入了解python。这次想尝试一下python中一个很重要的部分——爬虫。&lt;/p&gt;
&lt;h1 id=&quot;测试库&quot;&gt;测试库&lt;/h1&gt;
&lt;p&gt;先测试一下需要安装的库&lt;/p&gt;
&lt;figure clas</description>
        
      
      
      
      <content:encoded><![CDATA[<p>笔者在大一时曾系统学习过python，但也只掌握了一些基础的语法知识，并没有真正的深入了解python。这次想尝试一下python中一个很重要的部分——爬虫。</p><h1 id="测试库">测试库</h1><p>先测试一下需要安装的库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> selenium</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ok&quot;</span>)</span><br></pre></td></tr></table></figure><p>得到<code>ok</code>说明库安装完成。</p><p><img src="https://s3.bmp.ovh/imgs/2024/06/30/97997b0ca7853dae.png" alt=""></p><h1 id="爬取自己博客">爬取自己博客</h1><p><img src="https://s3.bmp.ovh/imgs/2024/06/30/6b944e76231a1c74.png" alt=""><br><code>r.status_code</code> 返回<code>200</code>，说明请求成功。<br>再尝试其他命令。</p><table><thead><tr><th style="text-align:left">常用属性</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">encoding</td><td style="text-align:left">查看或者指定响应字符编码</td></tr><tr><td style="text-align:left">status_code</td><td style="text-align:left">返回HTTP响应码</td></tr><tr><td style="text-align:left">url</td><td style="text-align:left">查看请求的 url 地址</td></tr><tr><td style="text-align:left">headers</td><td style="text-align:left">查看请求头信息</td></tr><tr><td style="text-align:left">cookies</td><td style="text-align:left">查看cookies 信息</td></tr><tr><td style="text-align:left">text</td><td style="text-align:left">以字符串形式输出</td></tr><tr><td style="text-align:left">content</td><td style="text-align:left">以字节流形式输出，若要保存下载图片需使用该属性</td></tr></tbody></table><h1 id="爬取百度">爬取百度</h1><p><img src="https://s3.bmp.ovh/imgs/2024/06/30/9d8ff71f11809ba5.png" alt=""><br>爬取成功。<br>尝试<code>r.headers</code>，发现<code>Content-Type</code>没有带编码信息<br><img src="https://s3.bmp.ovh/imgs/2024/06/30/ea8aca247671cec5.png" alt=""><br>默认为’ISO-8859-1’<br>再<code>r.text</code>，存在大量乱码。<br>查看网页源代码或观察text发现网页编码设定为’utf-8’<br>设置后可以正常显示。<br><img src="https://s3.bmp.ovh/imgs/2024/06/30/8657517cf24c39c8.png" alt=""></p><h1 id="url管理器">URL管理器</h1><p><img src="https://s3.bmp.ovh/imgs/2024/06/30/7a8a4f8e49280c6e.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UrlManager</span>():</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Url管理器</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.new_urls=<span class="built_in">set</span>()</span><br><span class="line">        self.old_urls=<span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 单个添加</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_new_url</span>(<span class="params">self,url</span>):</span><br><span class="line">        <span class="keyword">if</span> url <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(url)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> url <span class="keyword">in</span> self.new_urls <span class="keyword">or</span> url <span class="keyword">in</span> self.old_urls:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.new_urls.add(url)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 批量添加</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_new_urls</span>(<span class="params">self,urls</span>):</span><br><span class="line">        <span class="keyword">if</span> urls <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(urls)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">            self.add_new_url(url)</span><br><span class="line">    <span class="comment"># 从新URL集合中获取一个URL，并将其添加到旧URL集合中</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_url</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.has_new_url():</span><br><span class="line">            url=self.new_urls.pop()</span><br><span class="line">            self.old_urls.add(url)</span><br><span class="line">            <span class="keyword">return</span> url</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断是否存在url</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">has_new_url</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.new_urls)&gt;<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    url_manager=UrlManager()</span><br><span class="line">    url_manager.add_new_url(<span class="string">&quot;url1&quot;</span>)</span><br><span class="line">    url_manager.add_new_urls([<span class="string">&quot;url1&quot;</span>, <span class="string">&quot;url2&quot;</span>, <span class="string">&quot;url3&quot;</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;url_manager.new_urls&#125;</span>,<span class="subst">&#123;url_manager.old_urls&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">30</span>)</span><br><span class="line">    new_urls=url_manager.get_url()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;url_manager.new_urls&#125;</span>,<span class="subst">&#123;url_manager.old_urls&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span> * <span class="number">30</span>)</span><br><span class="line">    new_urls = url_manager.get_url()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;url_manager.new_urls&#125;</span>,<span class="subst">&#123;url_manager.old_urls&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span> * <span class="number">30</span>)</span><br><span class="line">    new_urls = url_manager.get_url()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;url_manager.new_urls&#125;</span>,<span class="subst">&#123;url_manager.old_urls&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span> * <span class="number">30</span>)</span><br><span class="line">    new_urls = url_manager.get_url()</span><br><span class="line">    <span class="built_in">print</span>(url_manager.has_new_url())</span><br></pre></td></tr></table></figure><h1 id="beautiful-soup-网页解析器">Beautiful Soup——网页解析器</h1><p>Beautiful Soup是python的一个库，最主要的功能是从网页抓取数据。官方解释如下：</p><blockquote><p>Beautiful Soup提供一些简单的、python式的函数用来处理导航、搜索、修改分析树等功能。它是一个工具箱，通过解析文档为用户提供需要抓取的数据，因为简单，所以不需要多少代码就可以写出一个完整的应用程序。<br>Beautiful Soup自动将输入文档转换为Unicode编码，输出文档转换为utf-8编码。你不需要考虑编码方式，除非文档没有指定一个编码方式，这时，Beautiful Soup就不能自动识别编码方式了。然后，你仅仅需要说明一下原始编码方式就可以了。<br>Beautiful Soup已成为和lxml、html6lib一样出色的python解释器，为用户灵活地提供不同的解析策略或强劲的速度。</p></blockquote><p>创建如下测试html文本</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">Content-Type</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>网页标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>标题2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>标题3<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>标题4<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span> <span class="attr">class</span>=<span class="string">&quot;default&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com&quot;</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.crazyant.net&quot;</span>&gt;</span>疯狂的蚂蚁<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://ww.iqiyi.com&quot;</span>&gt;</span>爱奇艺<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://www.python.org/static/img/python-logo.png&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>效果如下：<br><img src="https://s3.bmp.ovh/imgs/2024/06/30/bce235684dc8700c.png" alt=""><br>使用bs4</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./bs4_test.html&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> fin:</span><br><span class="line">    html_doc = fin.read()</span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(html_doc,<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line"></span><br><span class="line">div_node = soup.find(<span class="string">&#x27;div&#x27;</span>, <span class="built_in">id</span>=<span class="string">&quot;content&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(div_node)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;================================&quot;</span>)</span><br><span class="line">links = soup.find_all(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> link <span class="keyword">in</span> links:</span><br><span class="line">    <span class="built_in">print</span>(link.name,link[<span class="string">&quot;href&quot;</span>], link.get_text())</span><br><span class="line"></span><br><span class="line">img = soup.find(<span class="string">&quot;img&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(img[<span class="string">&quot;src&quot;</span>])</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行如下：<br><img src="https://s3.bmp.ovh/imgs/2024/06/30/1a575c57903de152.png" alt=""></p>]]></content:encoded>
      
      
      <category domain="http://wangzhilei.fun/categories/Python/">Python</category>
      
      
      <category domain="http://wangzhilei.fun/tags/Python%E7%88%AC%E8%99%AB/">Python爬虫</category>
      
      
      <comments>http://wangzhilei.fun/2024/06/23/Python%E7%88%AC%E8%99%AB%EF%BC%88%E4%B8%80%EF%BC%89/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>OFDM时频图</title>
      <link>http://wangzhilei.fun/2024/06/22/OFDM%E6%97%B6%E9%A2%91%E5%9B%BE/</link>
      <guid>http://wangzhilei.fun/2024/06/22/OFDM%E6%97%B6%E9%A2%91%E5%9B%BE/</guid>
      <pubDate>Sat, 22 Jun 2024 02:32:09 GMT</pubDate>
      
        
        
      <description>&lt;figure class=&quot;highlight matlab&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas</description>
        
      
      
      
      <content:encoded><![CDATA[<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% ======================== 绘制时域波形图=======================</span></span><br><span class="line">Fs = <span class="number">1000</span>;                                <span class="comment">% 总的采样率</span></span><br><span class="line">N = <span class="number">1024</span>;                                <span class="comment">% 总的子载波数</span></span><br><span class="line">T = N / Fs;                              <span class="comment">% 信号绘制为一个周期的长度</span></span><br><span class="line">x = <span class="number">0</span> : <span class="number">1</span>/Fs : T<span class="number">-1</span>/Fs;                   <span class="comment">% 生成时间向量，用于绘制波形</span></span><br><span class="line">Numscr = <span class="number">4</span>;                              <span class="comment">% 绘制的子载波数量</span></span><br><span class="line">s_data = <span class="number">1</span>;                              <span class="comment">% 初始相位</span></span><br><span class="line">y = <span class="built_in">zeros</span>(Numscr, <span class="built_in">numel</span>(x));             <span class="comment">% 初始化存储每个子载波的复数值的矩阵</span></span><br><span class="line">ini_phase = <span class="built_in">repmat</span>(s_data, <span class="number">1</span>, <span class="built_in">numel</span>(x));  <span class="comment">% 生成与时间长度相匹配的初始相位向量</span></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">0</span> : Numscr<span class="number">-1</span>                      <span class="comment">% 循环遍历要绘制的子载波数量</span></span><br><span class="line">    <span class="keyword">for</span> n = <span class="number">0</span> : <span class="built_in">numel</span>(x)<span class="number">-1</span>                <span class="comment">% 循环遍历时间序列</span></span><br><span class="line">        y(k+<span class="number">1</span>, n+<span class="number">1</span>) = ini_phase(n+<span class="number">1</span>) * <span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span> * <span class="number">2</span> * <span class="built_in">pi</span> * k * n / N);  <span class="comment">% 计算每个时间点上每个子载波的复数值</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(x, <span class="built_in">real</span>(y));                         <span class="comment">% 绘制时域波形</span></span><br><span class="line">xlabel(<span class="string">&#x27;时间/s&#x27;</span>);                      </span><br><span class="line">ylabel(<span class="string">&#x27;幅度/V&#x27;</span>);                        </span><br><span class="line"></span><br><span class="line"><span class="comment">% ======================== 绘制频域波形图=======================</span></span><br><span class="line">f = (-Fs/<span class="number">2</span> : Fs/<span class="built_in">numel</span>(x) : Fs/<span class="number">2</span>-Fs/<span class="built_in">numel</span>(x));</span><br><span class="line">a = <span class="number">20</span>;</span><br><span class="line">y1 = <span class="built_in">zeros</span>(Numscr, a * N);</span><br><span class="line">y_combined = horzcat(y, y1);              <span class="comment">% 水平拼接两个矩阵</span></span><br><span class="line">f = (-Fs/<span class="number">2</span> : Fs/((a+<span class="number">1</span>)*N) : (Fs/<span class="number">2</span>-Fs/((a+<span class="number">1</span>)*N)));</span><br><span class="line">y_fft = <span class="built_in">zeros</span>(Numscr, (a+<span class="number">1</span>)*N);</span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span> : Numscr</span><br><span class="line">    y_fft(k, :) = <span class="built_in">real</span>(fftshift(fft(y_combined(k,:)))) / N;  <span class="comment">% 计算每个子载波的频谱</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">plot</span>(f, y_fft(<span class="number">1</span>,:), f, y_fft(<span class="number">2</span>,:), f, y_fft(<span class="number">3</span>,:), f, y_fft(<span class="number">4</span>,:));</span><br><span class="line">grid on;</span><br><span class="line">xlim([<span class="number">-10</span>, <span class="number">10</span>]);                          <span class="comment">% 将 x 轴范围限制在 -10 到 10 之间</span></span><br><span class="line">xlabel(<span class="string">&#x27;频率/Hz&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;幅度/V&#x27;</span>);</span><br></pre></td></tr></table></figure><h1 id="绘制时域波形图">绘制时域波形图</h1><ol><li>定义采样率<code>Fs</code>、子载波数<code>N</code>、信号周期<code>T</code>、时间向量<code>x</code>、子载波数量<code>Numscr</code>、初始相位<code>s_data</code>。</li><li>初始化一个矩阵<code>y</code>来存储每个子载波的复数值，以及一个初始相位向量<code>ini_phase</code>。</li><li>使用双重循环计算每个子载波在每个时间点的复数值。外循环遍历子载波数量，内循环遍历时间序列。计算公式为<code>y(k+1, n+1) = ini_phase(n+1) * exp(1i * 2 * pi * k * n / N)</code>。</li><li>使用<code>plot</code>函数绘制时域波形，x轴为时间<code>s</code>，y轴为幅度<code>V</code>。</li></ol><p><img src="https://s3.bmp.ovh/imgs/2024/07/01/fb39953ac4738f2a.gif" alt=""></p><h1 id="绘制频域波形图">绘制频域波形图</h1><ol><li>定义频率向量<code>f</code>，扩展因子<code>a</code>，并初始化一个更大的矩阵<code>y1</code>来扩展<code>y</code>矩阵。</li><li>使用<code>horzcat</code>函数水平拼接<code>y</code>和<code>y1</code>矩阵，得到<code>y_combined</code>。</li><li>重新定义频率向量<code>f</code>以匹配扩展后的矩阵。</li><li>初始化一个矩阵<code>y_fft</code>来存储每个子载波的频谱。</li><li>使用循环计算每个子载波的频谱，通过对<code>y_combined</code>的每一行应用<code>fft</code>函数，然后使用<code>fftshift</code>函数进行频谱移位，并除以<code>N</code>进行归一化。</li><li>使用<code>plot</code>函数绘制频域波形图，x轴为频率<code>Hz</code>，y轴为幅度<code>V</code>。限制x轴范围在-10到10之间。</li></ol><p><img src="https://s3.bmp.ovh/imgs/2024/07/01/42575f8c0c3ef9e5.gif" alt=""></p><h1 id="总结">总结</h1><p>生成特定的时间序列和相应的复数值，来模拟和绘制四个子载波的时域波形。然后，通过对这些波形进行傅里叶变换，绘制出它们的频域波形图。</p>]]></content:encoded>
      
      
      <category domain="http://wangzhilei.fun/categories/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/">通信原理</category>
      
      
      <category domain="http://wangzhilei.fun/tags/OFDM/">OFDM</category>
      
      
      <comments>http://wangzhilei.fun/2024/06/22/OFDM%E6%97%B6%E9%A2%91%E5%9B%BE/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
